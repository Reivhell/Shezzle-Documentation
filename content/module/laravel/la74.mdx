---
title: "Sesi 74: Multi-tenancy Strategies"
description: "**Multi-tenancy** adalah arsitektur software di mana single instance aplikasi melayani multiple tenants (customers/organizations) secara simultan. Set..."
category: "laravel"
tags: ["laravel"]
order: 74
---

## 1. Apa itu Multi-tenancy?

**Multi-tenancy** adalah arsitektur software di mana single instance aplikasi melayani multiple tenants (customers/organizations) secara simultan. Setiap tenant memiliki data terisolasi meskipun berbagi resources yang sama.

**Analogi:** Seperti gedung apartemen — satu bangunan (aplikasi) dengan multiple unit (tenants) yang memiliki kunci masing-masing (isolation).

**Tipe Multi-tenancy:**

| Aspek | Database per Tenant | Shared Database |
|-------|---------------------|-----------------|
| **Isolasi Data** | Highest (physical) | Logical (row-level) |
| **Cost** | Higher (DB instances) | Lower (single DB) |
| **Complexity** | Infrastructure | Application |
| **Scaling** | Horizontal (add DB) | Vertical (bigger DB) |
| **Use Case** | Enterprise, compliance | SaaS, startups |

## 2. Database per Tenant

### 2.1 Arsitektur

```
Request: tenant1.app.com
           ↓
    Tenant Resolver (subdomain)
           ↓
    Database Connection Switch
           ↓
    ┌─────────────────┐
    │  tenant1_db     │ ◄── Isolated database
    │  - users        │
    │  - orders       │
    │  - settings     │
    └─────────────────┘

Request: tenant2.app.com
           ↓
    ┌─────────────────┐
    │  tenant2_db     │ ◄── Database berbeda
    │  - users        │
    │  - orders       │
    │  - settings     │
    └─────────────────┘
```

### 2.2 Implementasi

```php
<?php

// config/database.php
'connections' => [
    'tenant' => [
        'driver' => 'mysql',
        'host' => env('DB_HOST', '127.0.0.1'),
        'port' => env('DB_PORT', '3306'),
        // Database name akan di-set dynamically
        'database' => null,
        'username' => env('DB_USERNAME', 'forge'),
        'password' => env('DB_PASSWORD', ''),
    ],
],

// app/Models/Tenant.php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;

class Tenant extends Model
{
    protected $fillable = ['name', 'domain', 'database'];

    public function configure(): self
    {
        config([
            'database.connections.tenant.database' => $this->database,
        ]);

        DB::purge('tenant');
        DB::reconnect('tenant');

        return $this;
    }

    public function use(): self
    {
        $this->configure();
        
        // Set default connection
        DB::setDefaultConnection('tenant');
        
        return $this;
    }
}

// Middleware untuk tenant resolution
namespace App\Http\Middleware;

class IdentifyTenant
{
    public function handle($request, $next)
    {
        $host = $request->getHost();
        
        // Extract subdomain: tenant1.app.com → tenant1
        $subdomain = explode('.', $host)[0];
        
        $tenant = Tenant::where('domain', $subdomain)->firstOrFail();
        
        // Set tenant context untuk seluruh request
        $tenant->use();
        
        // Share ke app container
        app()->instance('current_tenant', $tenant);
        
        return $next($request);
    }
}
```

### 2.3 Tenant Database Creation

```php
<?php

namespace App\Services;

use App\Models\Tenant;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\DB;

class TenantProvisioner
{
    public function create(string $name, string $subdomain): Tenant
    {
        $database = "tenant_{$subdomain}_" . uniqid();
        
        // Create database
        DB::statement("CREATE DATABASE IF NOT EXISTS {$database}");
        
        // Create tenant record
        $tenant = Tenant::create([
            'name' => $name,
            'domain' => $subdomain,
            'database' => $database,
        ]);
        
        // Run migrations
        $tenant->configure();
        Artisan::call('migrate', [
            '--database' => 'tenant',
            '--path' => 'database/migrations/tenant',
            '--force' => true,
        ]);
        
        // Seed default data
        Artisan::call('db:seed', [
            '--database' => 'tenant',
            '--class' => 'TenantDatabaseSeeder',
            '--force' => true,
        ]);
        
        return $tenant;
    }
    
    public function delete(Tenant $tenant): void
    {
        $tenant->configure();
        
        // Backup dulu (optional)
        $this->backup($tenant);
        
        // Drop database
        DB::statement("DROP DATABASE IF EXISTS {$tenant->database}");
        
        $tenant->delete();
    }
}
```

## 3. Shared Database (Row-level Isolation)

### 3.1 Arsitektur

```
┌─────────────────────────────────────────┐
│           shared_database               │
│  ┌─────────┐  ┌─────────┐  ┌─────────┐ │
│  │  users  │  │ orders  │  │settings │ │
│  │---------│  │---------│  │---------│ │
│  │tenant_id│  │tenant_id│  │tenant_id│ │
│  │   1     │  │   1     │  │   1     │ │
│  │   2     │  │   2     │  │   2     │ │
│  │   3     │  │   3     │  │   3     │ │
│  └─────────┘  └─────────┘  └─────────┘ │
└─────────────────────────────────────────┘
         ↑
    WHERE tenant_id = X
```

### 3.2 Global Scope Implementation

```php
<?php

namespace App\Models\Traits;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Auth;

trait BelongsToTenant
{
    public static function bootBelongsToTenant(): void
    {
        static::creating(function (Model $model) {
            if (!$model->tenant_id && Auth::check()) {
                $model->tenant_id = Auth::user()->tenant_id;
            }
        });
        
        static::addGlobalScope('tenant', function (Builder $builder) {
            if (Auth::check()) {
                $builder->where('tenant_id', Auth::user()->tenant_id);
            }
        });
    }
    
    public function scopeWithoutTenant(Builder $builder): Builder
    {
        return $builder->withoutGlobalScope('tenant');
    }
}

// Model usage
namespace App\Models;

class Order extends Model
{
    use BelongsToTenant;
    
    protected $fillable = ['tenant_id', 'total', 'status'];
}

// Semua query otomatis filtered:
Order::all(); // SELECT * FROM orders WHERE tenant_id = ?

// Bypass scope untuk admin:
Order::withoutTenant()->where('status', 'pending')->get();
```

### 3.3 Tenant-aware Query Builder

```php
<?php

namespace App\Database;

use Illuminate\Database\Query\Builder as BaseBuilder;

class TenantQueryBuilder extends BaseBuilder
{
    public function insert(array $values): bool
    {
        // Auto-inject tenant_id
        $tenantId = app('current_tenant')?->id;
        
        if ($tenantId) {
            $values = array_map(function ($value) use ($tenantId) {
                $value['tenant_id'] = $tenantId;
                return $value;
            }, is_array(reset($values)) ? $values : [$values]);
        }
        
        return parent::insert($values);
    }
}

// Override default builder di model
protected function newBaseQueryBuilder()
{
    $connection = $this->getConnection();
    
    return new TenantQueryBuilder(
        $connection,
        $connection->getQueryGrammar(),
        $connection->getPostProcessor()
    );
}
```

## 4. Tenant Identification Strategies

### 4.1 Subdomain-based

```
tenant1.saas.com → Tenant ID: 1
tenant2.saas.com → Tenant ID: 2
```

```php
<?php

namespace App\Services\TenantIdentification;

class SubdomainStrategy implements TenantIdentificationStrategy
{
    public function identify(Request $request): ?Tenant
    {
        $host = $request->getHost();
        $parts = explode('.', $host);
        
        // Handle: tenant.domain.com
        if (count($parts) >= 3) {
            $subdomain = $parts[0];
            return Tenant::where('subdomain', $subdomain)->first();
        }
        
        return null;
    }
}
```

### 4.2 Domain-based (Custom Domain)

```
acme-corp.com → Tenant: Acme Corporation
tech-startup.io → Tenant: Tech Startup
```

```php
<?php

class DomainStrategy implements TenantIdentificationStrategy
{
    public function identify(Request $request): ?Tenant
    {
        $host = $request->getHost();
        
        // Cek custom domains table
        return Tenant::where('custom_domain', $host)->first();
    }
}

// SSL/TLS handling untuk custom domains
// Gunakan Let's Encrypt dengan wildcard atau individual certificates
```

### 4.3 Path-based

```
app.com/tenant1/dashboard → Tenant ID: 1
app.com/tenant2/dashboard → Tenant ID: 2
```

```php
<?php

class PathStrategy implements TenantIdentificationStrategy
{
    public function identify(Request $request): ?Tenant
    {
        $path = $request->path();
        $segments = explode('/', $path);
        
        if (count($segments) >= 1 && $segments[0] !== '') {
            $slug = $segments[0];
            return Tenant::where('slug', $slug)->first();
        }
        
        return null;
    }
}

// Route prefixing
Route::prefix('{tenant}')->middleware('identify.tenant')->group(function () {
    Route::get('/dashboard', [DashboardController::class, 'index']);
    Route::get('/settings', [SettingsController::class, 'index']);
});
```

### 4.4 Header-based (API)

```http
GET /api/orders
Host: api.saas.com
X-Tenant-ID: tenant-123
Authorization: Bearer token
```

```php
<?php

class HeaderStrategy implements TenantIdentificationStrategy
{
    public function identify(Request $request): ?Tenant
    {
        $tenantId = $request->header('X-Tenant-ID');
        
        if ($tenantId) {
            return Tenant::where('api_key', $tenantId)
                ->orWhere('id', $tenantId)
                ->first();
        }
        
        return null;
    }
}
```

## 5. Cache Isolation per Tenant

### 5.1 Cache Key Prefixing

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Cache;

class TenantCache
{
    private string $prefix;
    
    public function __construct()
    {
        $tenant = app('current_tenant');
        $this->prefix = $tenant ? "tenant:{$tenant->id}:" : 'global:';
    }
    
    public function get(string $key): mixed
    {
        return Cache::get($this->prefix . $key);
    }
    
    public function put(string $key, $value, $ttl = null): bool
    {
        return Cache::put($this->prefix . $key, $value, $ttl);
    }
    
    public function forget(string $key): bool
    {
        return Cache::forget($this->prefix . $key);
    }
    
    public function flush(): bool
    {
        // Hanya flush keys dengan prefix ini
        // Redis: SCAN + DEL pattern
        return Cache::tags(["tenant:{$this->getTenantId()}"])->flush();
    }
    
    private function getTenantId(): string
    {
        return app('current_tenant')?->id ?? 'global';
    }
}
```

### 5.2 Cache Tags untuk Multi-tenant

```php
<?php

// Redis cache store dengan tagging support
'redis' => [
    'driver' => 'redis',
    'connection' => 'cache',
    'lock_connection' => 'default',
],

// Usage
Cache::tags(["tenant:{$tenantId}", 'users'])->put('user-list', $users, 3600);
Cache::tags(["tenant:{$tenantId}", 'settings'])->put('config', $config, 3600);

// Flush semua cache tenant
Cache::tags("tenant:{$tenantId}")->flush();

// Flush specific resource untuk tenant
Cache::tags(["tenant:{$tenantId}", 'users'])->flush();
```

### 5.3 Tenant-aware Cache Middleware

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Support\Facades\Cache;

class TenantCacheMiddleware
{
    public function handle($request, Closure $next)
    {
        $tenant = app('current_tenant');
        
        if ($tenant) {
            // Override cache prefix untuk request ini
            config(['cache.prefix' => "tenant_{$tenant->id}"]);
            
            // Reconnect cache dengan prefix baru
            Cache::purge();
        }
        
        return $next($request);
    }
}
```

## 6. Queue Isolation Strategies

### 6.1 Queue per Tenant

```php
<?php

// Dispatch ke tenant-specific queue
class TenantAwareDispatcher
{
    public function dispatch($job, Tenant $tenant)
    {
        $queueName = "tenant:{$tenant->id}";
        
        return dispatch($job->onQueue($queueName));
    }
}

// Worker configuration (supervisor)
// Satu worker per tenant, atau worker yang handle multiple tenant queues

[program:tenant-worker]
command=php artisan queue:work --queue=tenant:1,tenant:2,tenant:3 --balance=auto
```

### 6.2 Shared Queue dengan Tenant Context

```php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;

abstract class TenantAwareJob implements ShouldQueue
{
    use Queueable;
    
    public ?int $tenantId;
    
    public function __construct()
    {
        $this->tenantId = app('current_tenant')?->id;
    }
    
    public function handle(): void
    {
        if ($this->tenantId) {
            $tenant = Tenant::find($this->tenantId);
            $tenant->use(); // Set database, cache, etc.
        }
        
        $this->tenantHandle();
    }
    
    abstract protected function tenantHandle(): void;
}

// Usage
class ProcessReport extends TenantAwareJob
{
    protected function tenantHandle(): void
    {
        // Database sudah switched ke tenant yang benar
        $data = Order::all(); // Auto-filtered by tenant
        
        // Generate report...
    }
}
```

### 6.3 Queue Isolation dengan Middleware

```php
<?php

namespace App\Queue\Middleware;

use App\Models\Tenant;

class SetTenantContext
{
    public function handle($job, $next)
    {
        if (property_exists($job, 'tenantId') && $job->tenantId) {
            $tenant = Tenant::find($job->tenantId);
            
            if ($tenant) {
                $tenant->use();
                app()->instance('current_tenant', $tenant);
            }
        }
        
        return $next($job);
    }
}

// Job implementation
class SendInvoice implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue;
    
    public $middleware = [
        SetTenantContext::class,
        // middleware lain...
    ];
    
    public function __construct(
        public int $tenantId,
        public int $invoiceId
    ) {}
}
```

## 7. Storage Isolation

### 7.1 Tenant-specific Storage Paths

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Storage;

class TenantStorage
{
    private string $disk;
    private string $basePath;
    
    public function __construct(string $disk = 's3')
    {
        $this->disk = $disk;
        $tenant = app('current_tenant');
        $this->basePath = $tenant ? "tenants/{$tenant->id}" : 'global';
    }
    
    public function path(string $path): string
    {
        return "{$this->basePath}/{$path}";
    }
    
    public function put(string $path, $contents, $options = []): string
    {
        $fullPath = $this->path($path);
        Storage::disk($this->disk)->put($fullPath, $contents, $options);
        return $fullPath;
    }
    
    public function url(string $path): string
    {
        return Storage::disk($this->disk)->url($this->path($path));
    }
    
    public function delete(string $path): bool
    {
        return Storage::disk($this->disk)->delete($this->path($path));
    }
    
    // List files untuk tenant ini saja
    public function files(string $directory = ''): array
    {
        $fullPath = $this->path($directory);
        return Storage::disk($this->disk)->files($fullPath);
    }
}

// Usage
$storage = new TenantStorage();
$storage->put('invoices/2024/001.pdf', $pdfContent);
$url = $storage->url('invoices/2024/001.pdf');
// Result: https://cdn.com/tenants/5/invoices/2024/001.pdf
```

### 7.2 S3 Bucket Policies untuk Isolation

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:PutObject",
                "s3:DeleteObject"
            ],
            "Resource": "arn:aws:s3:::saas-bucket/tenants/${aws:PrincipalTag/TenantId}/*"
        }
    ]
}
```

## 8. Security & Data Isolation

### 8.1 Database Connection Security

```php
<?php

// Enforce tenant isolation di database level
// PostgreSQL Row Level Security (RLS)

// Migration
DB::statement('
    CREATE POLICY tenant_isolation ON orders
    USING (tenant_id = current_setting(\'app.current_tenant\')::integer);
');

// Set session variable saat connect
DB::statement("SET app.current_tenant = {$tenantId}");
```

### 8.2 Query Protection

```php
<?php

namespace App\Providers;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;

class TenantSecurityProvider extends ServiceProvider
{
    public function boot()
    {
        // Prevent queries without tenant scope
        DB::listen(function ($query) {
            if (app()->environment('production')) {
                $sql = strtolower($query->sql);
                
                // Check tables yang require tenant_id
                $tenantTables = ['orders', 'users', 'invoices', 'settings'];
                
                foreach ($tenantTables as $table) {
                    if (str_contains($sql, $table) && 
                        !str_contains($sql, 'tenant_id') &&
                        !str_contains($sql, 'without_tenant')) {
                        
                        logger()->warning('Query without tenant scope detected', [
                            'sql' => $query->sql,
                            'trace' => debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 10),
                        ]);
                    }
                }
            }
        });
    }
}
```

## Kesimpulan

Multi-tenancy Strategies mencakup:
- **Database per Tenant**: Isolasi fisik, cocok untuk enterprise dengan compliance requirements
- **Shared Database**: Cost-effective, menggunakan row-level isolation dengan global scopes
- **Tenant Identification**: Subdomain, custom domain, path, atau header-based resolution
- **Cache Isolation**: Prefixing dan tagging untuk prevent data leakage antar tenant
- **Queue Isolation**: Dedicated queues atau context injection untuk background jobs
- **Storage Isolation**: Path-based segregation untuk file uploads
- **Security**: Database-level policies dan query monitoring untuk enforce isolation

Selanjutnya di **Sesi 75**, kita akan membahas Microservices & Distributed Systems: service discovery, inter-service communication, distributed transactions, dan API Gateway patterns.
```
