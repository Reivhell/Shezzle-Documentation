---
title: "Sesi 78: Event Sourcing & CQRS"
description: "**Event Sourcing** adalah pattern di mana state aplikasi tidak disimpan sebagai current state, melainkan sebagai sequence of events. State saat ini di..."
category: "laravel"
tags: ["laravel"]
order: 78
---

## 1. Apa itu Event Sourcing?

**Event Sourcing** adalah pattern di mana state aplikasi tidak disimpan sebagai current state, melainkan sebagai sequence of events. State saat ini direkonstruksi dengan "memutar ulang" (replay) semua events.

**Traditional CRUD:**
```
Database: User { id: 1, name: "John", email: "john@example.com", status: "active" }

Update: name → "Jane"
Database: User { id: 1, name: "Jane", email: "john@example.com", status: "active" }

Problem: History hilang, siapa yang ganti? kapan? kenapa?
```

**Event Sourcing:**
```
Event Store:
1. UserRegistered { userId: 1, name: "John", email: "john@example.com", occurredAt: "2024-01-01" }
2. UserEmailChanged { userId: 1, oldEmail: "john@example.com", newEmail: "john.doe@example.com", occurredAt: "2024-01-15" }
3. UserNameChanged { userId: 1, oldName: "John", newName: "Jane", reason: "Marriage", occurredAt: "2024-02-01" }

Current State: Replay semua events → User { id: 1, name: "Jane", email: "john.doe@example.com" }
```

**Keuntungan Event Sourcing:**
- **Complete Audit Trail**: Setiap perubahan tercatat dengan metadata (who, when, why)
- **Temporal Query**: "Berapa stock kita tanggal 15 Januari?"
- **Event Replay**: Fix bugs dengan replay events dengan kode yang sudah diperbaiki
- **Projections**: Build read models optimized untuk specific queries
- **Integration**: Events bisa dipublish ke systems lain

**Trade-offs:**
- Complexity lebih tinggi
- Event schema evolution challenging
- Replay bisa lambat untuk aggregates dengan banyak events

## 2. CQRS (Command Query Responsibility Segregation)

### 2.1 Apa itu CQRS?

**CQRS** memisahkan model untuk **Commands** (writes) dan **Queries** (reads). Dalam traditional CRUD, satu model handle keduanya. Dalam CQRS, mereka dipisahkan untuk optimization.

**Traditional:**
```
┌─────────────┐         ┌─────────────┐
│   Client    │◄───────►│  User Model │
│             │         │  (read/write)│
└─────────────┘         └──────┬──────┘
                               │
                        ┌──────┴──────┐
                        │   Database   │
                        └─────────────┘
```

**CQRS:**
```
Commands (Write)                    Queries (Read)
┌─────────────┐                    ┌─────────────┐
│   Client    │                    │   Client    │
└──────┬──────┘                    └──────┬──────┘
       │                                  │
       ▼                                  ▼
┌─────────────┐                    ┌─────────────┐
│  Command    │                    │   Query     │
│  Handler    │                    │   Handler   │
│  (Domain    │                    │  (Optimized │
│   Model)    │                    │   DTOs)     │
└──────┬──────┘                    └──────┬──────┘
       │                                  │
       ▼                                  ▼
┌─────────────┐                    ┌─────────────┐
│  Event      │                    │  Read Model │
│  Store      │◄─────Events───────┤  (Projection)│
│  (Events)   │                    │  (Denormalized)
└─────────────┘                    └─────────────┘
```

### 2.2 Read vs Write Models

```php
<?php

// WRITE MODEL (Event Sourced Aggregate)
// Core/Domain/Aggregates/Order.php

namespace App\Core\Domain\Aggregates;

use App\Core\Domain\Events\OrderCreated;
use App\Core\Domain\Events\OrderItemAdded;
use App\Core\Domain\Events\OrderConfirmed;
use App\Core\Domain\ValueObjects\Money;

class Order
{
    private string $id;
    private string $customerId;
    private array $items = [];
    private string $status = 'pending';
    private Money $total;
    
    // State rebuild dari events
    public static function reconstituteFromEvents(array $events): self
    {
        $order = new self();
        
        foreach ($events as $event) {
            $order->apply($event);
        }
        
        return $order;
    }
    
    // Apply event untuk rebuild state
    public function apply(object $event): void
    {
        match (get_class($event)) {
            OrderCreated::class => $this->applyOrderCreated($event),
            OrderItemAdded::class => $this->applyOrderItemAdded($event),
            OrderConfirmed::class => $this->applyOrderConfirmed($event),
        };
    }
    
    private function applyOrderCreated(OrderCreated $event): void
    {
        $this->id = $event->orderId;
        $this->customerId = $event->customerId;
        $this->total = Money::zero($event->currency);
    }
    
    private function applyOrderItemAdded(OrderItemAdded $event): void
    {
        $this->items[] = [
            'productId' => $event->productId,
            'quantity' => $event->quantity,
            'price' => $event->unitPrice,
        ];
        $this->total = $this->total->add(
            $event->unitPrice->multiply($event->quantity)
        );
    }
    
    private function applyOrderConfirmed(OrderConfirmed $event): void
    {
        $this->status = 'confirmed';
        $this->confirmedAt = $event->confirmedAt;
    }
    
    // Business methods yang generate events
    public function addItem(string $productId, int $quantity, Money $unitPrice): void
    {
        if ($this->status !== 'pending') {
            throw new \DomainException('Cannot modify confirmed order');
        }
        
        // Record event, jangan ubah state langsung!
        $this->recordEvent(new OrderItemAdded(
            orderId: $this->id,
            productId: $productId,
            quantity: $quantity,
            unitPrice: $unitPrice,
            occurredAt: now()
        ));
    }
    
    public function confirm(): void
    {
        $this->recordEvent(new OrderConfirmed(
            orderId: $this->id,
            confirmedAt: now()
        ));
    }
}

// READ MODEL (Projection/Denormalized)
// Optimized untuk queries, tidak ada business logic

namespace App\ReadModels;

use Illuminate\Database\Eloquent\Model;

class OrderView extends Model
{
    protected $table = 'order_views';
    public $timestamps = false;
    
    protected $casts = [
        'items' => 'array',
        'total_amount' => 'decimal:2',
        'confirmed_at' => 'datetime',
    ];
    
    // Optimized untuk specific queries
    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }
    
    public function scopeForCustomer($query, string $customerId)
    {
        return $query->where('customer_id', $customerId);
    }
    
    // Pre-calculated fields untuk avoid joins
    public function scopeWithTotalAbove($query, float $amount)
    {
        return $query->where('total_amount', '>', $amount);
    }
}
```

## 3. Spatie Event Sourcing Package

### 3.1 Installation dan Setup

```bash
composer require spatie/laravel-event-sourcing

php artisan vendor:publish --provider="Spatie\EventSourcing\EventSourcingServiceProvider"

php artisan migrate
```

### 3.2 Aggregate Root dengan Spatie

```php
<?php

namespace App\Aggregates;

use Spatie\EventSourcing\AggregateRoots\AggregateRoot;
use App\Events\OrderCreated;
use App\Events\OrderItemAdded;
use App\Events\OrderConfirmed;
use App\Events\OrderCancelled;

class OrderAggregate extends AggregateRoot
{
    private string $status = 'pending';
    private array $items = [];
    private int $itemCount = 0;
    private float $totalAmount = 0;
    
    // State rebuild otomatis oleh Spatie berdasarkan type hinted methods
    
    public function applyOrderCreated(OrderCreated $event): void
    {
        $this->status = 'pending';
    }
    
    public function applyOrderItemAdded(OrderItemAdded $event): void
    {
        $this->items[] = $event->attributes;
        $this->itemCount++;
        $this->totalAmount += $event->attributes['subtotal'];
    }
    
    public function applyOrderConfirmed(OrderConfirmed $event): void
    {
        $this->status = 'confirmed';
    }
    
    public function applyOrderCancelled(OrderCancelled $event): void
    {
        $this->status = 'cancelled';
    }
    
    // Business methods
    
    public function create(string $customerId, string $currency): self
    {
        $this->recordThat(new OrderCreated(
            customerId: $customerId,
            currency: $currency,
            occurredAt: now()
        ));
        
        return $this;
    }
    
    public function addItem(string $productId, string $productName, int $quantity, float $unitPrice): self
    {
        if ($this->status !== 'pending') {
            throw new \DomainException('Cannot add items to non-pending order');
        }
        
        if ($quantity > 100) {
            throw new \DomainException('Maximum 100 items per product');
        }
        
        $this->recordThat(new OrderItemAdded(
            productId: $productId,
            productName: $productName,
            quantity: $quantity,
            unitPrice: $unitPrice,
            subtotal: $quantity * $unitPrice,
            occurredAt: now()
        ));
        
        return $this;
    }
    
    public function confirm(): self
    {
        if ($this->status !== 'pending') {
            throw new \DomainException('Only pending orders can be confirmed');
        }
        
        if ($this->itemCount === 0) {
            throw new \DomainException('Cannot confirm empty order');
        }
        
        $this->recordThat(new OrderConfirmed(
            confirmedAt: now(),
            totalAmount: $this->totalAmount
        ));
        
        return $this;
    }
    
    public function cancel(string $reason): self
    {
        if ($this->status === 'confirmed') {
            throw new \DomainException('Cannot cancel confirmed order');
        }
        
        $this->recordThat(new OrderCancelled(
            reason: $reason,
            cancelledAt: now()
        ));
        
        return $this;
    }
    
    // Getters untuk current state
    public function getStatus(): string
    {
        return $this->status;
    }
    
    public function getTotalAmount(): float
    {
        return $this->totalAmount;
    }
}
```

### 3.3 Events Definition

```php
<?php

namespace App\Events;

use Spatie\EventSourcing\StoredEvents\ShouldBeStored;

class OrderCreated extends ShouldBeStored
{
    public function __construct(
        public readonly string $customerId,
        public readonly string $currency,
        public readonly string $occurredAt
    ) {}
}

class OrderItemAdded extends ShouldBeStored
{
    public function __construct(
        public readonly string $productId,
        public readonly string $productName,
        public readonly int $quantity,
        public readonly float $unitPrice,
        public readonly float $subtotal,
        public readonly string $occurredAt
    ) {}
}

class OrderConfirmed extends ShouldBeStored
{
    public function __construct(
        public readonly string $confirmedAt,
        public readonly float $totalAmount
    ) {}
}

class OrderCancelled extends ShouldBeStored
{
    public function __construct(
        public readonly string $reason,
        public readonly string $cancelledAt
    ) {}
}
```

### 3.4 Projectors (Read Model Builders)

```php
<?php

namespace App\Projectors;

use Spatie\EventSourcing\EventHandlers\Projectors\Projector;
use App\Events\OrderCreated;
use App\Events\OrderItemAdded;
use App\Events\OrderConfirmed;
use App\ReadModels\OrderView;
use App\ReadModels\OrderItemView;

class OrderProjector extends Projector
{
    public function onOrderCreated(OrderCreated $event, string $aggregateUuid): void
    {
        OrderView::create([
            'uuid' => $aggregateUuid,
            'customer_id' => $event->customerId,
            'status' => 'pending',
            'currency' => $event->currency,
            'total_amount' => 0,
            'item_count' => 0,
            'created_at' => $event->occurredAt,
        ]);
    }
    
    public function onOrderItemAdded(OrderItemAdded $event, string $aggregateUuid): void
    {
        $order = OrderView::find($aggregateUuid);
        
        // Update denormalized order view
        $order->update([
            'total_amount' => $order->total_amount + $event->subtotal,
            'item_count' => $order->item_count + $event->quantity,
        ]);
        
        // Create detailed item view (untuk order detail page)
        OrderItemView::create([
            'order_uuid' => $aggregateUuid,
            'product_id' => $event->productId,
            'product_name' => $event->productName,
            'quantity' => $event->quantity,
            'unit_price' => $event->unitPrice,
            'subtotal' => $event->subtotal,
        ]);
    }
    
    public function onOrderConfirmed(OrderConfirmed $event, string $aggregateUuid): void
    {
        OrderView::find($aggregateUuid)->update([
            'status' => 'confirmed',
            'confirmed_at' => $event->confirmedAt,
        ]);
    }
    
    // Reset read model (untuk replay)
    public function resetState(): void
    {
        OrderView::truncate();
        OrderItemView::truncate();
    }
}
```

### 3.5 Reactors (Side Effects)

```php
<?php

namespace App\Reactors;

use Spatie\EventSourcing\EventHandlers\Reactors\Reactor;
use App\Events\OrderConfirmed;
use App\Notifications\OrderConfirmationNotification;

class OrderConfirmationReactor extends Reactor
{
    public function onOrderConfirmed(OrderConfirmed $event, string $aggregateUuid): void
    {
        // Send email notification (side effect, tidak mengubah state)
        $order = OrderView::find($aggregateUuid);
        $customer = Customer::find($order->customer_id);
        
        $customer->notify(new OrderConfirmationNotification($order));
        
        // Update inventory (panggil service lain)
        app(InventoryService::class)->reserveStockForOrder($aggregateUuid);
        
        // Publish integration event
        event(new OrderConfirmedIntegrationEvent(
            orderId: $aggregateUuid,
            customerId: $order->customer_id,
            total: $event->totalAmount
        ));
    }
}
```

## 4. Snapshotting untuk Performance

### 4.1 Apa itu Snapshotting?

**Problem**: Aggregate dengan 10,000 events akan lambat di-load karena harus replay semua events.

**Solusi**: **Snapshot** — periodic save dari current state. Load aggregate: load snapshot terakhir + replay events setelah snapshot.

```
Events: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]

Tanpa Snapshot:
Load → Replay 1-15 (15 operations)

Dengan Snapshot (setiap 5 events):
Snapshot at 10: State after event 10
Load → Load Snapshot 10 + Replay 11-15 (6 operations)
```

### 4.2 Spatie Snapshot Implementation

```php
<?php

namespace App\Aggregates;

use Spatie\EventSourcing\AggregateRoots\AggregateRoot;
use Spatie\EventSourcing\AggregateRoots\Snapshot;

class OrderAggregate extends AggregateRoot
{
    // Spatie handle snapshotting otomatis jika di-configure
    
    protected int $snapshotThreshold = 50; // Snapshot setiap 50 events
    
    public function shouldBeSnapshotted(): bool
    {
        // Custom logic untuk determine kapan snapshot
        return $this->getStoredEventCount() % 50 === 0;
    }
    
    public function getState(): array
    {
        // Return serializable state untuk snapshot
        return [
            'status' => $this->status,
            'items' => $this->items,
            'itemCount' => $this->itemCount,
            'totalAmount' => $this->totalAmount,
        ];
    }
    
    public function useState(array $state): void
    {
        // Restore state dari snapshot
        $this->status = $state['status'];
        $this->items = $state['items'];
        $this->itemCount = $state['itemCount'];
        $this->totalAmount = $state['totalAmount'];
    }
}

// Manual snapshotting
$order = OrderAggregate::retrieve($orderUuid);
$order->snapshot(); // Force snapshot creation
```

## 5. Event Replay Strategies

### 5.1 Replay untuk Recovery

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Spatie\EventSourcing\Facades\Projectionist;

class ReplayEventsCommand extends Command
{
    protected $signature = 'events:replay
                            {projector? : Specific projector to replay}
                            {--from=0 : Start from event number}
                            {--to= : Stop at event number}';

    public function handle()
    {
        $projector = $this->argument('projector');
        
        if ($projector) {
            // Replay specific projector
            $projectorClass = "App\\Projectors\\{$projector}";
            Projectionist::replay([$projectorClass], $this->option('from'));
        } else {
            // Replay all projectors
            Projectionist::replay(
                Projectionist::getProjectors()->all(),
                $this->option('from')
            );
        }
        
        $this->info('Events replayed successfully');
    }
}
```

### 5.2 Replay untuk New Feature (New Projection)

```php
<?php

// Tambah projector baru untuk existing events
namespace App\Projectors;

use Spatie\EventSourcing\EventHandlers\Projectors\Projector;
use App\Events\OrderConfirmed;
use App\ReadModels\DailyRevenueView;

class DailyRevenueProjector extends Projector
{
    public function onOrderConfirmed(OrderConfirmed $event, string $aggregateUuid): void
    {
        $date = date('Y-m-d', strtotime($event->confirmedAt));
        
        DailyRevenueView::updateOrCreate(
            ['date' => $date],
            ['revenue' => DB::raw("revenue + {$event->totalAmount}")]
        );
    }
}

// Deploy:
// 1. Create migration untuk daily_revenue_views table
// 2. Deploy code (projector tidak akan menerima events baru sampai replay)
// 3. Run: php artisan events:replay DailyRevenueProjector
// 4. Projector sekarang up-to-date dan akan menerima events baru
```

### 5.3 Versioned Events (Schema Evolution)

```php
<?php

namespace App\Events;

use Spatie\EventSourcing\StoredEvents\ShouldBeStored;

// Version 1 (Original)
class OrderCreatedV1 extends ShouldBeStored
{
    public function __construct(
        public readonly string $customerId,
        public readonly string $currency
    ) {}
}

// Version 2 (Added shipping address)
class OrderCreated extends ShouldBeStored
{
    public function __construct(
        public readonly string $customerId,
        public readonly string $currency,
        public readonly ?array $shippingAddress = null // New optional field
    ) {}
    
    // Upgrade dari V1
    public static function fromV1(OrderCreatedV1 $old): self
    {
        return new self(
            customerId: $old->customerId,
            currency: $old->currency,
            shippingAddress: null // Default untuk old events
        );
    }
}

// Event Upgrader
namespace App\EventUpgraders;

use Spatie\EventSourcing\EventSerializers\EventUpgrader;

class OrderCreatedUpgrader implements EventUpgrader
{
    public function upgrade(array $event): array
    {
        if (!isset($event['shipping_address'])) {
            $event['shipping_address'] = null;
        }
        
        return $event;
    }
}
```

## 6. CQRS Query Handlers

```php
<?php

namespace App\Application\Queries;

// Query DTOs
class GetOrderQuery
{
    public function __construct(
        public readonly string $orderId,
        public readonly ?string $customerId = null // untuk authorization
    ) {}
}

class ListCustomerOrdersQuery
{
    public function __construct(
        public readonly string $customerId,
        public readonly int $page = 1,
        public readonly int $perPage = 20,
        public readonly ?string $status = null,
        public readonly ?string $sortBy = 'created_at',
        public readonly string $sortOrder = 'desc'
    ) {}
}

// Query Handlers
class OrderQueryHandler
{
    public function __construct(
        private OrderViewRepository $repository
    ) {}
    
    public function getOrder(GetOrderQuery $query): ?OrderDetailDto
    {
        $order = $this->repository->findById($query->orderId);
        
        if (!$order || $order->customer_id !== $query->customerId) {
            return null;
        }
        
        return new OrderDetailDto(
            id: $order->uuid,
            status: $order->status,
            total: $order->total_amount,
            currency: $order->currency,
            items: $order->items->map(fn ($i) => new OrderItemDto(...)),
            createdAt: $order->created_at,
            canBeCancelled: $order->status === 'pending'
        );
    }
    
    public function listCustomerOrders(ListCustomerOrdersQuery $query): PaginatedResult
    {
        $builder = OrderView::forCustomer($query->customerId);
        
        if ($query->status) {
            $builder->where('status', $query->status);
        }
        
        $paginator = $builder
            ->orderBy($query->sortBy, $query->sortOrder)
            ->paginate($query->perPage, ['*'], 'page', $query->page);
        
        return new PaginatedResult(
            items: $paginator->map(fn ($o) => new OrderListItemDto(...)),
            total: $paginator->total(),
            page: $paginator->currentPage(),
            perPage: $paginator->perPage()
        );
    }
}
```

## Kesimpulan

Event Sourcing & CQRS menyediakan:
- **Event Sourcing**: State sebagai derived view dari immutable event log
- **CQRS**: Optimized read models (projections) terpisah dari write models (aggregates)
- **Spatie Integration**: Aggregate roots, projectors, reactors, dan snapshotting
- **Projections**: Build denormalized views untuk specific query patterns
- **Snapshotting**: Performance optimization untuk aggregates dengan banyak events
- **Event Replay**: Recovery, new feature deployment, dan bug fixing

Cocok untuk: Audit requirements, complex domains, analytics-heavy applications, systems dengan frequent read pattern changes.

Tidak cocok untuk: Simple CRUD, systems dengan low write volume, teams tanpa DDD experience.

Selanjutnya di **Sesi 79**, kita akan membahas Serverless dengan Laravel: Laravel Vapor, AWS Lambda patterns, cold start optimization, dan queue handling dalam environment serverless.
```
